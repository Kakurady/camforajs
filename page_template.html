<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Page Title</title>

  <script src="ext/d3/d3.js" charset="utf-8"></script>
  <script src="ext/gl-matrix/gl-matrix.js" charset="utf-8"></script>

<body>

<!-- run after the DOM is ready  -->
<script type="text/javascript">
  glMatrix.setMatrixArrayType(Array);
  
  /// list of leader (human-controlled) robots (usually only one).
  var leaders = [
    { 
      // question: 2-axis, 3-axis, or homogenous coordinates?
      pos: [400, 240, 0],
      /// max movement speed, in pixels per second.
      speed:  200,
      
      // currently assuming zero turning radius... zero minimum movement distance
      // implementation-specific? ( will need to be rebuilt for robots )
      movementStartPos: [0, 0, 0],
      movementStartTime: -1,
      movementEndPos: [0, 0, 0],
      movementEndTime: 0
    }
  ];
  
  var robots = [];
  
  /// elapsed time in simulation (in seconds)
  var simulationTime = 0;
  /// when running in real time, the epoch from when the simulation time is counted.
  /// (scheduler private variable; may change due to pausing simulations)
  var startTime;
  
  /// data passed to renderer. May not countain all data from source.
  /// (core private variable, cached to minimize GC)
  var renderData = {
    leaders: leaders,
    robots: robots
  }
  
  var rendererOptions = {};
  var svgRenderer = (function makeSVGRenderer( options ){
    // our canvas element. a d3 selection containing one (1) svg element
    var s = d3.select("body").append("svg");
    s.attr("width", 800);
    s.attr("height", 480);
  
    function renderGraphics(data){
      var leader_update = s.selectAll("circle.leader").data(data.leaders);

      leader_update.enter()
        .append("circle")
        .classed("leader", true)
        .attr("r", 15);
      leader_update
        .attr("cx", function(d) { return d.pos[0]; })
        .attr("cy", function(d) { return d.pos[1]; })
      leader_update.exit().remove();
      
      var robot_update = s.selectAll("circle.robot").data(data.robots);

      robot_update.enter()
        .append("circle")
        .classed("robot", true)
        .attr("r", 15);
      robot_update
        .attr("cx", function(d) { return d.pos[0]; })
        .attr("cy", function(d) { return d.pos[1]; })
      robot_update.exit().remove();
    }
    
    return {
      attachedElement: s,
      renderGraphics: renderGraphics,
      addRobot: function addRobot(){ ; }
    };
  })( rendererOptions );
  
  var renderer = svgRenderer;
  
  // FIXME HACK making sure the leader starts at its position (need better method for robots)
  vec3.copy (leaders[0].movementEndPos, leaders[0].pos);
  function moveLeader(simulationTime){
    var leader = leaders[0];
    
    // every frame: interpolate current position
    // (  the idea is that we pretend computations happens in an instant,
    //    that is, at the current `simulationTime`.
    //    and movements happen over an interval, that is, between the last
    //    `simulationTime` and the current `simulationTime`. (this is called a
    //    _frame_ when running in realtime, as used in video games, because
    //    each update result in one image being displayed.)
    //    so the position calculation is used to "catch up" the simulation
    //    to the instant when computations happen.
    //    this way, when a robot finishes its _MOVE_ phrase, it can begin
    //    the _LOOK_ and _COMPUTE_ phrase in the same frame, making a smoother-
    //    looking simulation.
    //
    //    if we run the position update after the computation, then a robot that
    //    finished _MOVE_ment between instants `t-1` and `t` would not start its
    //    _COMPUTE_ phrase until `t+1`.
    //    it's possible to get around this by making the animation start time
    //    before the compute instant, but this effectively makes robots being
    //    able to see into the future.
    //  )
    vec3.lerp(
      leader.pos, 
      leader.movementStartPos, 
      leader.movementEndPos, 
      Math.min(1, (simulationTime - leader.movementStartTime) / (leader.movementEndTime - leader.movementStartTime) )
      );
    
    if (simulationTime >= leader.movementEndTime){
      // FIXME perf: creates garbage that needs to be collected
      var offset = vec3.fromValues(400, 240, 0);
      var howfar = vec3.create();
      
      // set new start position and time
      
      vec3.copy(leader.movementStartPos, leader.pos);
      leader.movementStartTime = simulationTime;
      
      // set new end position and time
      
      vec2.random(leader.movementEndPos, 240);
      vec3.add(leader.movementEndPos, leader.movementEndPos, offset);
      // figure out the animation end time
      vec3.sub(howfar, leader.pos, leader.movementEndPos);
      var duration = vec2.length(howfar) / leader.speed;
      // set a random speed
      duration = duration * ( 0.5 + Math.random(0.5) );
      leader.movementEndTime = leader.movementStartTime + duration;
    }
    

  }

  function drawNextFrame(timestamp){
  //https://developer.mozilla.org/en-US/docs/Games/Anatomy
  
    window.requestAnimationFrame(drawNextFrame);
    
    startTime = startTime || timestamp;
    simulationTime = (timestamp - startTime) / 1000;
    
    // TODO: poll manual leader movement (gamepad/mouse)
    
    // update robots
    moveLeader(simulationTime);
    
    // run computations
    
    // extract state for rendering
    renderData.leaders = leaders;
    renderData.robots = robots;
    renderData.simulationTime = simulationTime;
    
    // render simulation and visualization
    renderer.renderGraphics(
      renderData   );
  }
  
  // FIXME: requestAnimationFrame won't work in IE9.
  // Whether we need to support China needs to be thought 
  window.requestAnimationFrame (drawNextFrame);  
  
  // next up: make a small demo of moving stuff
</script>
</body>
</html>
